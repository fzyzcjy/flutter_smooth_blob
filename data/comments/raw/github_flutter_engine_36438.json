{"source": "github", "metadata": {"org": "flutter", "repo": "engine", "issue": 36438}, "content": {"author": {"login": "fzyzcjy"}, "body": "1. I will finish code details, refine code, add tests, make tests pass, etc, after a code review that thinks the *rough idea* is acceptable. It is because, from my past experience, reviews may request changing a lot. If the general idea is to be changed, all detailed implementation efforts are wasted :)\r\n2. The PR has an already-working counterpart, and it produces ~60FPS smooth experimental results. The benchmark results and detailed analysis is in chapter https://cjycode.com/flutter_smooth/benchmark/. All the source code is in  https://github.com/fzyzcjy/engine/tree/flutter-smooth and https://github.com/fzyzcjy/flutter/tree/flutter-smooth.\r\n3. Possibly useful as a context to this PR, there is a whole chapter discussing the internals - how flutter_smooth is implemented. (Link: https://cjycode.com/flutter_smooth/design/)\r\n\r\n---\r\n\r\n\r\n\r\nThis PR is a part for implementing the 60fps smooth rendering (#101227).\r\n\r\n*List which issues are fixed by this PR. You must list at least one issue.*\r\nhttps://github.com/flutter/flutter/issues/101227\r\n\r\n*If you had to change anything in the [flutter/tests] repo, include a link to the migration guide as per the [breaking change policy].*\r\n\r\nThe only change is an \"if\" as follows (all else are just tests)\r\n\r\n![image](https://user-images.githubusercontent.com/5236035/192693744-86842381-384b-4a81-97b6-9988767a871e.png)\r\n\r\n\r\n## Pre-launch Checklist\r\n\r\n- [x] I read the [Contributor Guide] and followed the process outlined there for submitting PRs.\r\n- [x] I read the [Tree Hygiene] wiki page, which explains my responsibilities.\r\n- [x] I read and followed the [Flutter Style Guide] and the [C++, Objective-C, Java style guides].\r\n- [x] I listed at least one issue that this PR fixes in the description above.\r\n- [x] I added new tests to check the change I am making or feature I am adding, or Hixie said the PR is test-exempt. See [testing the engine] for instructions on\r\nwriting and running engine tests.\r\n- [x] I updated/added relevant documentation (doc comments with `///`).\r\n- [x] I signed the [CLA].\r\n- [x] All existing and new tests are passing.\r\n\r\nIf you need help, consider asking for advice on the #hackers-new channel on [Discord].\r\n\r\n<!-- Links -->\r\n[Contributor Guide]: https://github.com/flutter/flutter/wiki/Tree-hygiene#overview\r\n[Tree Hygiene]: https://github.com/flutter/flutter/wiki/Tree-hygiene\r\n[Flutter Style Guide]: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo\r\n[C++, Objective-C, Java style guides]: https://github.com/flutter/engine/blob/main/CONTRIBUTING.md#style\r\n[testing the engine]: https://github.com/flutter/flutter/wiki/Testing-the-engine\r\n[CLA]: https://cla.developers.google.com/\r\n[flutter/tests]: https://github.com/flutter/tests\r\n[breaking change policy]: https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes\r\n[Discord]: https://github.com/flutter/flutter/wiki/Chat\r\n\r\nBy the way, the tests and code does work: If I comment out the code, the tests fail.\r\n\r\n![image](https://user-images.githubusercontent.com/5236035/192442910-0fd05944-98b2-4272-9dc1-8c01308ab203.png)\r\n![image](https://user-images.githubusercontent.com/5236035/192442965-c2fb185e-8fa3-4e67-8eec-a627dcbe3ffe.png)\r\n", "comments": [{"id": "IC_kwDOAlZRSc5LIBzy", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "Not sure whether I should \"@\" some people here, maybe @dnfield @jonahwilliams @gaaclarke @flar engine experts?\r\n\r\nMay I get a code review, thanks :)", "createdAt": "2022-09-28T05:10:55Z", "includesCreatedEdit": true, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1260395762"}, {"id": "IC_kwDOAlZRSc5LIGya", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "@dnfield Hi, thanks for the quick reply :)\r\n\r\n> The documentation on FlutterView.render specifies when it is safe/allowed to call render.\r\n\r\nI will change that doc accordingly (probably after we come to a conclusion what should be done for this PR)\r\n\r\n> I'm not quite clear on how this will affect the pipeline - it seems like it will now be trivial for a dart:ui application to flood the pipeline if we remove guardrails around when you can call render. Today the contract is that the application can expect that it's time to call render because it got a call to onBeginFrame. In this world, the application calls render whenever it thinks it has been working too long and might want to give an update. But the application doesn't know about vsync and it will be very hard to reason about why render is getting called if we make this change.\r\n> I don't think we should make this change. It too easily allows wasted work to happen.\r\n\r\nFirstly, IMHO, a normal flutter app calls `window.render` once per frame, so no problem at all for all existing app.\r\n\r\nSecondly, in my proposal (`Preempt for 60 FPS`), I do observe vsync (using VsyncAwaiter class), and only submit one `window.render` per vsync. Therefore, \"But the application doesn't know about vsync\" seems not to be the situation, and thus \"it will be very hard to reason about why render is getting called\" is also no problem.\r\n\r\nThat said, I do agree that, if the rasterizer thread takes too long (e.g. takes 50ms for one rasterize), it is a waste to submit a Scene per 16.6ms (but should submit per 50ms).\r\n\r\nIf this is still a problem for you, can I change as follows: Add a flag to `window.render`, say, `window.render({bool onlyRenderOncePerBeginFrame = true})`. Then the behavior will be exactly the same, except for someone who really needs this (e.g. the Preempt proposal).\r\n\r\nIn addition, given it is a so low-level API that most people will never touch, it seems reasonable to provide some flexibility to it.", "createdAt": "2022-09-28T05:43:21Z", "includesCreatedEdit": true, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1260416154"}, {"id": "IC_kwDOAlZRSc5LJHuJ", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "@dnfield Another possibility for Dart code to understand the queue is full so it do not do anything more:\r\n\r\nAdd this 4-line function:\r\n\r\n```c++\r\n// return: whether it is prepared successfully. If return false, it means pipeline is full, \r\n// and thus the user should not really compute the Scene to avoid unnecessary work.\r\nbool Animator::PrepareExtraRender() {\r\n  if (!producer_continuation_) {\r\n    producer_continuation_ = layer_tree_pipeline_->Produce();\r\n  }\r\n  return static_cast<bool>(producer_continuation_);\r\n}\r\n```\r\n\r\nusage:\r\n\r\n```dart\r\nrealize_next_vsync_comes; // see the design for details https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit\r\nvar prepared = window.prepareExtraRender();\r\nif (prepared) {\r\n  ui.Scene scene = compute_the_scene();\r\n  window.render(scene);\r\n} else {\r\n  // do not do anything since the rasterizer queue is already so full\r\n  // this mimic the behavior of Animator::BeginFrame, where we skip the current frame if it is full\r\n}\r\n```", "createdAt": "2022-09-28T10:06:35Z", "includesCreatedEdit": true, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1260682121"}, {"id": "IC_kwDOAlZRSc5LJKSY", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "> @dnfield ... be trivial for a dart:ui application to flood the pipeline ...\r\n\r\nIMHO the pipeline seems not to be flooded - it has depth 2. In other words, even if we call `window.render(scene)` a million times within a frame, only the first two scenes will be in the queue, and the rest 999998 will just be thrown away (suppose rasterizer has not processed any). So we are still safe.\r\n\r\nFor a dart:ui application, if needed, it can use the `window.prepareExtraRender` extra call to see whether the queue is already full, to avoid generating scene etc (just like example above).\r\n\r\n> Today the contract is that the application can expect that it's time to call render because it got a call to onBeginFrame. In this world, the application calls render whenever it thinks it has been working too long and might want to give an update.\r\n\r\nJust as mentioned above, adding a flag like `window.render({bool onlyRenderOncePerBeginFrame = true})` seems to solve the \"contract\" problem.\r\n\r\n", "createdAt": "2022-09-28T10:15:48Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1260692632"}, {"id": "IC_kwDOAlZRSc5LJKe2", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "Oops sorry @chinmaygarde and @iskakaushik I just clicked the \"Icons.refresh\" on dnfield and do not know why github remove review requests to you...", "createdAt": "2022-09-28T10:16:30Z", "includesCreatedEdit": true, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1260693430"}, {"id": "IC_kwDOAlZRSc5LMjiV", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "If we are worried that users may submit multiple window.render inside one vsync, another possibility: We may add some code in the C++ layer (or Dart layer), such that we check current vsync status, and *only* `Produce()` if it is a new vsync that has not been produced before.", "createdAt": "2022-09-28T23:57:11Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1261582485"}, {"id": "IC_kwDOAlZRSc5LVSzt", "author": {"login": "dnfield"}, "authorAssociation": "MEMBER", "body": "Fizzling like that would be expensive, and we'd be giving developers a button to push that actually makes things slower. We should avoid that.", "createdAt": "2022-09-30T18:11:41Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [{"content": "THUMBS_UP", "users": {"totalCount": 1}}, {"content": "CONFUSED", "users": {"totalCount": 2}}], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1263873261"}, {"id": "IC_kwDOAlZRSc5LWKAD", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "@dnfield If speed is a concern, maybe the original PR is ok: For a normal usage, it only adds `if (!producer_continuation_)` (and that if will return false immediately). Given that `explicit operator bool() const { return continuation_ != nullptr; }`, this if will only check whether a pointer is nullptr, so I guess it is only a few CPU cycles (per 16667 microseconds, i.e. maybe 10000000 cycles). In addition, for a normal usage, the branch will always be false, so IMHO the cpu branch predictor will be quite correct about the prediction.", "createdAt": "2022-09-30T22:42:21Z", "includesCreatedEdit": true, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1264099331"}, {"id": "IC_kwDOAlZRSc5LWNO6", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "> @dnfield giving developers a button to push that actually makes things slower\r\n\r\nThere seems to be another way that is not very slower:\r\n\r\nFirstly, the `onlyRenderOncePerBeginFrame` should not be `window.render(onlyRenderOncePerBeginFrame: true)`, but be `window.onlyRenderOncePerBeginFrame = true; window.render()`. In other words, it should be a flag that is set once. Then the code is:\r\n\r\n```c++\r\n...\r\n  if (!onlyRenderOncePerBeginFrame && !producer_continuation_) {\r\n    producer_continuation_ = layer_tree_pipeline_->Produce();\r\n  }\r\n...\r\n\r\nvoid SetOnlyRenderOncePerBeginFrame(bool value) { this->onlyRenderOncePerBeginFrame = value; }\r\nclass Animator { ... bool onlyRenderOncePerBeginFrame; ... }\r\n```\r\n\r\n(no need for locks, since all on UI thread.)\r\n\r\nThen there comes the concern that `if (!onlyRenderOncePerBeginFrame && !producer_continuation_)` can cost CPU cycles, even when onlyRenderOncePerBeginFrame is always true (for a classical user). Firstly, for a classical user, we only pay extra cost of `if(boolean)` (because && is short-circuited), so only a few cycles.\r\n\r\nSecondly, seems we can use the `[[likely]]` (c++20), or `LIKELY` (a lot of c++ library write their own version for that, e.g. see [how linux])(https://stackoverflow.com/questions/109710/how-do-the-likely-unlikely-macros-in-the-linux-kernel-work-and-what-is-their-ben) does that), to further hint compiler about this case to speed up.\r\n\r\n", "createdAt": "2022-09-30T22:51:53Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1264112570"}, {"id": "IC_kwDOAlZRSc5LWNme", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "@dnfield And for *zero* speed decrease if you like:\r\n\r\nThe `Animator::PrepareExtraRender` proposal seems to cause zero speed loss for a classical user. Because a classical user never calls that function, and only call Animator::Render. But Animator::Render is not modified in this proposal. For a smooth user, there does exist overhead, because need to call one extra C++ function - the PrepareExtraRender.", "createdAt": "2022-09-30T22:55:53Z", "includesCreatedEdit": true, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1264114078"}, {"id": "IC_kwDOAlZRSc5LcULm", "author": {"login": "dnfield"}, "authorAssociation": "MEMBER", "body": "You're discounting the time it takes to actually make a native call from Dart.\r\n\r\nOn top of that, we should not expose an API that might or might not do something and developers have no good way to reason about whether they're really supposed to call it or not.\r\n\r\nThis proposal is fundamentally changing the invariants around `render`/`onBeginFrame`, but it's not providing any way for developers to know if they're using the new invariants correctly or not. Even if the new potentially useless API is relatively cheap, it adds up when developers (and packages they use) start doing it multiple times per frame. And those developers/packages will have no way to know whether they're doing it correctly or not, so it will definitely get misused.\r\n\r\nWhy, for example, shouldn't the framework just call render and schedule a new frame when its hit its potential limit?", "createdAt": "2022-10-03T16:24:41Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1265713894"}, {"id": "IC_kwDOAlZRSc5LeJNh", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "@dnfield Hi thanks for the reply.\r\n\r\n> You're discounting the time it takes to actually make a native call from Dart.\r\n\r\nOriginally I thought that is small just like a normal function call... Ok now I learn it.\r\n\r\n> On top of that, we should not expose an API that might or might not do something and developers have no good way to reason about whether they're really supposed to call it or not.\r\n\r\nIndeed they have a way to reason: look at time or vsync info. They should not submit twice inside one vsync interval.\r\n\r\n> This proposal is fundamentally changing the invariants around render/onBeginFrame, but it's not providing any way for developers to know if they're using the new invariants correctly or not.\r\n\r\nI am not sure, if I expose the vsync info and ensure only one call is made per vsync interval (16.67ms), does this satisfy your requirement?\r\n\r\n> Even if the new potentially useless API is relatively cheap, it adds up when developers (and packages they use) start doing it multiple times per frame. \r\n\r\nAgain, as mentioned above, dev should not call it multiple times per frame. A naive dev may use `DateTime.now() - last_vsync_time > 15ms` etc to check, and a more sophisticated way may be read the vsync info (exposed from engine) to really ensure we never call twice per vsync interval. \r\n\r\n> And those developers/packages will have no way to know whether they're doing it correctly or not, so it will definitely get misused.\r\n\r\nThen maybe we should return `bool` to indicate whether it is really scheduled. If they see a lot of `false` they are doing it wrong (call too many times that are useless).\r\n\r\n> Why, for example, shouldn't the framework just call render and schedule a new frame when its hit its potential limit?\r\n\r\nBecause of the fundamental design of the preempt proposal (https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit), mainly \"The flow chart\" section.\r\n\r\nIndeed, window.render is called per vsync interval (16.67ms). The main difference from classical code is that, it may be called multiple times per onBeginFrame (when onBeginFrame is super slow).", "createdAt": "2022-10-03T23:26:28Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1266193249"}, {"id": "IC_kwDOAlZRSc5LeOt0", "author": {"login": "dnfield"}, "authorAssociation": "MEMBER", "body": "Devices do not always have 60fps vsync - sometimes it's 90 or 120 or more or less (at one point we had a customer looking at 240hz devices, and it's likely there are customers out there looking at 30hz use cases). There is no way currently in dart:ui to know what the current refresh rate is, and on some platforms it's not even possible to implement because the vendors don't provide an API for it (e.g. some Android vendors), and it can change from frame to frame.\r\n\r\nIn other words, a developer must not assume that 16.67ms is the right interval for a frame in all circumstances. And the query of `DateTime.now` is almost certain to _not_ match the actual vsync start time, so if you assume you have roughly 16ms from onBeginFrame you might actually overshoot vsync.", "createdAt": "2022-10-03T23:52:26Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1266215796"}, {"id": "IC_kwDOAlZRSc5LePb1", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "> Devices do not always have 60fps vsync - sometimes it's 90 or 120 or more or less (at one point we had a customer looking at 240hz devices, and it's likely there are customers out there looking at 30hz use cases). There is no way currently in dart:ui to know what the current refresh rate is, and on some platforms it's not even possible to implement because the vendors don't provide an API for it (e.g. some Android vendors), and it can change from frame to frame.\r\n\r\nDefinitely! That's why I also propose to expose vsync-related information to the dev. Last week you asked me to describe it and it was at \"Get last vsync time information\" section of google doc.\r\n\r\n> And the query of DateTime.now is almost certain to not match the actual vsync start time, so if you assume you have roughly 16ms from onBeginFrame you might actually overshoot vsync.\r\n\r\nTotally agree. Indeed in my (previous) implementation, I let the C++ side expose the `timeStamp` (i.e. vsync target time we provide to dart tonBeginFrame) both a \"Duration\" and a \"DateTime-compatible time\". If you like I can add that back (deleted it b/c want to make PR small).", "createdAt": "2022-10-03T23:57:18Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1266218741"}, {"id": "IC_kwDOAlZRSc5LePqg", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "P.S. I am also considering relaxing when to start a onBeginFrame which seems to reduce unnecessary idle time and improve performance. That may be related to the big picture you are concerned - how vsync and code are interacted. I will add it to design doc and reply here maybe in an hour.", "createdAt": "2022-10-03T23:58:56Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1266219680"}, {"id": "IC_kwDOAlZRSc5LeXPi", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "@dnfield Here it goes: \"Relax onBeginFrame starting criterion\" section in https://docs.google.com/document/d/1FuNcBvAPghUyjeqQCOYxSt6lGDAQ1YxsNlOvrUx0Gko/edit", "createdAt": "2022-10-04T00:34:41Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1266250722"}, {"id": "IC_kwDOAlZRSc5LiM27", "author": {"login": "dnfield"}, "authorAssociation": "MEMBER", "body": "I think it would be easier to start with a patch that exposes more about vsync timings to the developer, because that will be critical to whether this one makes sense.", "createdAt": "2022-10-04T16:23:59Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1267256763"}, {"id": "IC_kwDOAlZRSc5Lj45n", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "Thanks, I will do that.", "createdAt": "2022-10-04T23:05:16Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1267699303"}, {"id": "IC_kwDOAlZRSc5LkGgB", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "@dnfield Hi, PR is here: https://github.com/flutter/engine/pull/36607\r\n\r\nOnly the API is there currently, because IMHO the implementation details is unrelated to thoughts about this issue, and the API (and therefore implementations) are subject to changes.", "createdAt": "2022-10-05T00:16:04Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1267755009"}, {"id": "IC_kwDOAlZRSc5NISur", "author": {"login": "dnfield"}, "authorAssociation": "MEMBER", "body": "Let's close this one out to get it off review queues until we have more consensus around the approach.", "createdAt": "2022-10-27T20:18:50Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1294019499"}, {"id": "IC_kwDOAlZRSc5NJCp2", "author": {"login": "fzyzcjy"}, "authorAssociation": "CONTRIBUTOR", "body": "All right...", "createdAt": "2022-10-27T23:03:46Z", "includesCreatedEdit": false, "isMinimized": false, "minimizedReason": "", "reactionGroups": [], "url": "https://github.com/flutter/engine/pull/36438#issuecomment-1294215798"}], "createdAt": "2022-09-27T05:49:30Z", "title": "Allow render to be called multiple times for one BeginFrame"}}